package Graph;

import java.util.ArrayList;
import java.util.List;

import Util.Parser;

public class No924MinimizeMalwareSpread {

	public static void main(String[] args) {
		No924MinimizeMalwareSpread sol = new No924MinimizeMalwareSpread();
		Parser p = new Parser();
		String t = "[[1,1,0],[1,1,0],[0,0,1]]\n" + 
				"[0,1]\n" + 
				"[[1,0,0],[0,1,0],[0,0,1]]\n" + 
				"[0,2]\n" + 
				"[[1,1,1],[1,1,1],[1,1,1]]\n" + 
				"[1,2]";
		String[] s = t.split("\n");
		for(int i = 0; i < s.length; i+=2) {
			int[][] graph = p.parseMatrix(s[i]);
			int[] initial = p.parseArray(s[i+1]);
			int ans = sol.minMalwareSpread(graph, initial);
			System.out.println(ans);
		}
	}

	public int minMalwareSpread(int[][] graph, int[] initial) {
		// --> time = O(E), where E = number of edges in the graph
		
		// Thanks to:
		// https://leetcode.com/problems/minimize-malware-spread/solution/
		
		// Intuition:
		// Use same color to color nodes in the same component.
		// We know if two nodes have same color in initial list and we remove either of them,
		// the number of final ineffected nodes won't change.
		// We want to find the node in initial list whose color represent the largeest component in the graph.
		
		
		
		int cSize = 0, N = graph.length;
        int[] colors = new int[N];
        List<Integer> CompSize = new ArrayList<Integer>();
        CompSize.add(-1); // skip color 0
        for(int u: initial){
            if(colors[u] == 0){
                int compSize = drawColor(graph, N, u, colors, ++cSize);
                CompSize.add(compSize);
            }
        }
        
        // filter out same color nodes
        int[] colorCount = new int[cSize+1];
        for(int u: initial) colorCount[colors[u]]++;
        
        int node = Integer.MAX_VALUE, size = 0;
        for(int u: initial){
            // if(colorCount[colors[u]] > 1) continue;
            int colorSize = CompSize.get(colors[u]);
            if(colorSize > size){
                size = colorSize;
                node = u;
            }else if(colorSize == size && u < node){
                node = u;
            }
        }
        
        // no answer then return node with min id.
        if(node == Integer.MAX_VALUE){
            for(int n: initial) n = Math.min(node, n);
        }
        
        return node;
    }
    
    private int drawColor(int[][] graph, int N, int u, int[] colors, int color){
        int ret = 1;
        colors[u] = color;
        for(int v = 0; v < N; v++){
            if(v != u && graph[u][v] == 1 && colors[v] == 0)
                ret += drawColor(graph, N, v, colors, color);
        }
        return ret;
    }
}
